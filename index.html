// Temporary: Always show the page even if API fails
window.addEventListener('load', function() {
  // Force show the pond section
  const pondSection = document.getElementById('pondSection');
  const mobileButtons = document.getElementById('mobileButtons');
  
  if (pondSection) {
    pondSection.style.display = 'block';
  }
  if (mobileButtons) {
    mobileButtons.style.display = 'block';
  }
  
  // Load initial drawings from localStorage as fallback
  setTimeout(() => {
    const items = JSON.parse(localStorage.getItem('pondItems') || '[]');
    if (items.length > 0) {
      loadPondItems();
    }
  }, 1000);
});

// Modify your fetchDrawings function to have a fallback:
async function fetchDrawings() {
  try {
    const apiHealthy = await checkAPIHealth();
    if (!apiHealthy) {
      // Fallback to localStorage
      return JSON.parse(localStorage.getItem('pondItems') || '[]');
    }
    
    const response = await fetch(`${API_BASE}/drawings`);
    if (!response.ok) throw new Error('Failed to fetch');
    return await response.json();
  } catch (error) {
    console.error('Failed to fetch drawings, using localStorage fallback:', error);
    return JSON.parse(localStorage.getItem('pondItems') || '[]');
  }
}
<script>
// API Base URL - Use relative paths for Vercel
const API_BASE = '/api';

// DRAWING LOGIC
const canvas = document.getElementById("draw-area");
const ctx = canvas.getContext("2d");

// Set canvas size based on device
function setupCanvas() {
    if (window.innerWidth <= 768) {
        canvas.width = 250;
        canvas.height = 250;
    } else {
        canvas.width = 200;
        canvas.height = 200;
    }
    
    ctx.fillStyle = '#FFF9F0';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 12;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
}

setupCanvas();

let drawing = false;
let currentColor = "#c43a3a";
let hasDrawing = false;
let loadedDrawingIds = new Set();

// API functions - UPDATED FOR CORRECT PATHS
async function fetchDrawings() {
    try {
        const response = await fetch(`${API_BASE}/drawings`);
        if (!response.ok) throw new Error('Failed to fetch');
        return await response.json();
    } catch (error) {
        console.error('Failed to fetch drawings:', error);
        return [];
    }
}

async function saveDrawing(drawingData) {
    try {
        const response = await fetch(`${API_BASE}/drawings/add`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(drawingData)
        });
        return await response.json();
    } catch (error) {
        console.error('Failed to save drawing:', error);
        return { success: false };
    }
}

async function deleteDrawingFromServer(id) {
    try {
        const response = await fetch(`${API_BASE}/drawings/delete`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ id })
        });
        return await response.json();
    } catch (error) {
        console.error('Failed to delete drawing:', error);
        return { success: false };
    }
}

function selectColor(color, element) {
    currentColor = color;
    document.querySelectorAll('.color-dot').forEach(dot => {
        dot.classList.remove('selected');
    });
    element.classList.add('selected');
}

// Mouse events for desktop
canvas.addEventListener("mousedown", startDrawing);
canvas.addEventListener("mouseup", stopDrawing);
canvas.addEventListener("mouseout", stopDrawing);
canvas.addEventListener("mousemove", draw);

// Touch events for mobile
canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
canvas.addEventListener("touchend", handleTouchEnd);

function startDrawing(e) {
    drawing = true;
    hasDrawing = true;
    ctx.beginPath();
    const pos = getMousePos(e);
    ctx.moveTo(pos.x, pos.y);
    draw(e);
}

function stopDrawing() {
    drawing = false;
    ctx.beginPath();
}

function draw(e) {
    if (!drawing) return;
    
    const pos = getMousePos(e);
    ctx.strokeStyle = currentColor;
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
    hasDrawing = true;
}

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    let x, y;
    
    if (e.type.includes('touch')) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
    } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
    }
    
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    return {
        x: x * scaleX,
        y: y * scaleY
    };
}

function handleTouchStart(e) {
    e.preventDefault();
    drawing = true;
    hasDrawing = true;
    ctx.beginPath();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousedown", {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}

function handleTouchMove(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousemove", {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}

function handleTouchEnd(e) {
    e.preventDefault();
    const mouseEvent = new MouseEvent("mouseup", {});
    canvas.dispatchEvent(mouseEvent);
}

function clearCanvas() {
    ctx.fillStyle = '#FFF9F0';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    hasDrawing = false;
}

function isCanvasBlank() {
    const blank = document.createElement('canvas');
    blank.width = canvas.width;
    blank.height = canvas.height;
    const blankCtx = blank.getContext('2d');
    blankCtx.fillStyle = '#FFF9F0';
    blankCtx.fillRect(0, 0, blank.width, blank.height);
    return canvas.toDataURL() === blank.toDataURL();
}

function typeWithPauses() {
    const toolTitle = document.getElementById('toolTitle');
    const message = "That's not a drawing. Try again?";
    toolTitle.innerHTML = '';
    
    let i = 0;
    function type() {
        if (i < message.length) {
            toolTitle.innerHTML += message.charAt(i);
            i++;
            setTimeout(type, 80);
        } else {
            setTimeout(() => {
                toolTitle.innerHTML = "Drop Something Into Our Pond?";
            }, 2000);
        }
    }
    type();
}

function showAddingMessage() {
    const addButton = document.getElementById('addButton');
    addButton.textContent = "Adding...";
    addButton.disabled = true;
    addButton.style.opacity = '0.7';
    
    let dots = 0;
    const maxDots = 3;
    
    function animateDots() {
        dots = (dots + 1) % (maxDots + 1);
        addButton.textContent = "Adding" + '.'.repeat(dots);
        if (dots < maxDots) {
            setTimeout(animateDots, 500);
        } else {
            setTimeout(() => {
                addButton.textContent = "üêü Add to Pond";
                addButton.disabled = false;
                addButton.style.opacity = '1';
            }, 500);
        }
    }
    animateDots();
}

function getRandomPondPosition() {
    const pondArea = {
        left: 15,
        right: 85,  
        top: 20,
        bottom: 80
    };
    
    return {
        x: Math.random() * (pondArea.right - pondArea.left) + pondArea.left,
        y: Math.random() * (pondArea.bottom - pondArea.top) + pondArea.top
    };
}

function generateDrawingId() {
    return 'drawing_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// ADD TO POND - UPDATED FOR KV DATABASE
async function addToPond() {
    if (isCanvasBlank()) {
        typeWithPauses();
        return;
    }
    
    showAddingMessage();
    
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
    
    const whiteCanvas = document.createElement('canvas');
    whiteCanvas.width = canvas.width;
    whiteCanvas.height = canvas.height;
    const whiteCtx = whiteCanvas.getContext('2d');
    whiteCtx.fillStyle = '#FFF9F0';
    whiteCtx.fillRect(0, 0, whiteCanvas.width, whiteCanvas.height);
    
    const originalData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const whiteData = whiteCtx.getImageData(0, 0, whiteCanvas.width, whiteCanvas.height);
    const newData = tempCtx.createImageData(canvas.width, canvas.height);
    
    for (let i = 0; i < originalData.data.length; i += 4) {
        const r1 = originalData.data[i];
        const g1 = originalData.data[i + 1];
        const b1 = originalData.data[i + 2];
        
        const r2 = whiteData.data[i];
        const g2 = whiteData.data[i + 1];
        const b2 = whiteData.data[i + 2];
        
        if (r1 !== r2 || g1 !== g2 || b1 !== b2) {
            newData.data[i] = r1;
            newData.data[i + 1] = g1;
            newData.data[i + 2] = b1;
            newData.data[i + 3] = 255;
        }
    }
    
    tempCtx.putImageData(newData, 0, 0);
    const imgData = tempCanvas.toDataURL('image/png');
    const position = getRandomPondPosition();
    
    const newItem = {
        id: generateDrawingId(),
        img: imgData,
        x: position.x,
        y: position.y,
        timestamp: Date.now()
    };
    
    // Save to KV database instead of localStorage
    const result = await saveDrawing(newItem);
    
    if (result.success) {
        clearCanvas();
        addSingleDrawing(newItem);
        
        if (window.innerWidth <= 768) {
            setTimeout(() => {
                hideDrawingTools();
            }, 1500);
        }
    }
}

function addSingleDrawing(item) {
    const container = document.getElementById("pondDrawings");
    
    if (loadedDrawingIds.has(item.id)) {
        return;
    }
    
    let img = document.createElement("img");
    img.src = item.img;
    img.style.left = item.x + "%";
    img.style.top = item.y + "%";
    img.setAttribute('data-id', item.id);
    
    if (window.innerWidth > 768) {
        let clickCount = 0;
        img.addEventListener('click', function() {
            clickCount++;
            if (clickCount >= 3) {
                deleteDrawing(item.id);
                clickCount = 0;
            }
        });
    }
    
    container.appendChild(img);
    loadedDrawingIds.add(item.id);
}

async function deleteDrawing(id) {
    const result = await deleteDrawingFromServer(id);
    
    if (result.success) {
        const img = document.querySelector(`img[data-id="${id}"]`);
        if (img) {
            img.remove();
        }
        loadedDrawingIds.delete(id);
    }
}

// LOAD POND ITEMS - UPDATED FOR KV DATABASE
async function loadPondItems() {
    const items = await fetchDrawings();
    const container = document.getElementById("pondDrawings");
    
    const newItems = items.filter(item => !loadedDrawingIds.has(item.id));
    
    if (newItems.length > 0) {
        newItems.forEach((item, index) => {
            setTimeout(() => {
                addSingleDrawing(item);
            }, index * 400);
        });
    }
}

// REAL-TIME SYNC - UPDATED FOR KV DATABASE
async function syncDrawings() {
    const items = await fetchDrawings();
    const container = document.getElementById("pondDrawings");
    
    const currentDisplayedIds = new Set();
    container.querySelectorAll('img[data-id]').forEach(img => {
        currentDisplayedIds.add(img.getAttribute('data-id'));
    });
    
    // Remove drawings that are no longer in database
    container.querySelectorAll('img[data-id]').forEach(img => {
        const id = img.getAttribute('data-id');
        const existsInStorage = items.some(item => item.id === id);
        if (!existsInStorage) {
            img.remove();
            loadedDrawingIds.delete(id);
        }
    });
    
    // Add drawings that are in database but not displayed
    items.forEach(item => {
        if (!currentDisplayedIds.has(item.id)) {
            addSingleDrawing(item);
        }
    });
}

function showDrawingTools() {
    const toolsSection = document.getElementById('toolsSection');
    const mobileButtons = document.getElementById('mobileButtons');
    const pondSection = document.getElementById('pondSection');
    
    toolsSection.classList.add('mobile-visible');
    mobileButtons.classList.add('hidden');
    pondSection.classList.add('hidden');
}

function hideDrawingTools() {
    const toolsSection = document.getElementById('toolsSection');
    const mobileButtons = document.getElementById('mobileButtons');
    const pondSection = document.getElementById('pondSection');
    
    toolsSection.classList.remove('mobile-visible');
    mobileButtons.classList.remove('hidden');
    pondSection.classList.remove('hidden');
}

window.addEventListener('resize', setupCanvas);

// Initialize
loadPondItems();

// Real-time sync
setInterval(syncDrawings, 2000);

document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        syncDrawings();
    }
});

window.addEventListener('focus', syncDrawings);
</script>
